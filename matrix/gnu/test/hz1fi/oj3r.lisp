;; name project oj3r
;; name program oj3r
;; name extension newlisp
;; name describer R
;; name data 3
;; name unit 3

;; The value of x depends on the value returned by if expression. Now the symbol result
;; contains a string depending on the value of x.

;; 3.2 Looping
;; Sometimes you want to repeat a series of actions more than once, going round in a loop.
;; There are various possibilities. You might want to do the actions:
;; • on every item in a list
;; • on every item in a string
;; • a certain number of times
;; • until something happens
;; • while some condition prevails
;; newLISP has a solution for all of these, and more.

;; 3.2.1 Working through a list
;; newLISP programmers love lists, so dolist is a most useful function that sets a local loop
;; symbol (variable) to each item of a list in turn, and runs a series of actions on each. Put
;; the name for the loop variable and the list to be scanned, in parentheses, after dolist, then
;; follow it with the actions.
;; In the following example, I set another symbol called counter as well, before deﬁning a local
;; loop variable i that will hold each value of the list of numbers generated by the sequence
;; function:

(define counter 1)
(dolist (i (sequence -5 5))
(println "Element" counter ": " i)
(inc counter))

;; Notice that, unlike if, the dolist function and many other control words let you write a
;; series of expressions one after the other: here both the println and the inc (increment)
;; functions are called for each element of the list.
;; There's a useful shortcut for accessing a system-maintained loop counter. Just now I used a
;; counter symbol, incremented each time through the loop, to keep track of how far we'd got
;; in the list. However, newLISP automatically maintains a loop counter for you, in a system
;; variable called $idx, so I can dispense with the counter symbol, and just retrieve the value
;; of $idx each time through the loop:

(dolist (i (sequence -5 5))
(println "Element" $idx ": " i))

;; Notice that, unlike if, the dolist function and many other control words let you write a
;; series of expressions one after the other: here both the println and the inc (increment)
;; functions are called for each element of the list.
;; There's a useful shortcut for accessing a system-maintained loop counter. Just now I used a
;; counter symbol, incremented each time through the loop, to keep track of how far we'd got
;; in the list. However, newLISP automatically maintains a loop counter for you, in a system
;; variable called $idx, so I can dispense with the counter symbol, and just retrieve the value
;; of $idx each time through the loop:

(dolist (i (sequence -5 5))
(println "Element " $idx ": " i))

;; In some situations, you might prefer to use the mapping function map for processing a list
;; (described later - see Apply and map: applying functions to lists3 ). map can be used to
;; apply a function (either an existing function or a temporary deﬁnition) to every element
;; in a list, without going through the list using a local variable. For example, let's use map
;; to produce the same output as the above dolist function. I deﬁne a temporary print and
;; increase function consisting of two expressions, and apply this to each element of the list
;; produced by sequence:

(define counter 1)
        (map (fn (i)
             (println "Element " counter ": " i)
             (inc counter))
             (sequence -5 5))

;; Experienced LISP programmers may be more familiar with lambda. fn is a synonym for
;; lambda: use whichever one you prefer.
;; You might also ﬁnd ﬂat useful for working through lists, because it ﬂattens out lists con-
;; taining nested lists for easier processing, by copying:

(* (+ 1 2 3) (+ 4 5 6) 78)             
(+ 1 2 3 4 5 6)             

;; for example. See ﬂat4 .
;; To work through the arguments supplied to a function, you can use the doargs function.
;; See Arguments: args5 .

;; 3.2.2 Working through a string
;; You can step through every character in a string using the equivalent of dolist, dostring.
(define alphabet "abcdefghijklmnopqrstuvwxyz")
        (dostring (letter alphabet)
        (print letter { }))
        
        
;; The numbers are the ASCII/Unicode codes.

;; 3.2.3 A certain number of times

;; If you want to do something a ﬁxed number of times, use dotimes or for. dotimes carries
;; out a given number of repeats of the actions in the body of the list. You should provide a
;; name for the local variable, just like you did with dolist:

(dotimes (c 10)
(println c " times 3 is " (* c 3)))

        
